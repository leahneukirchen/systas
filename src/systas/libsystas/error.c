/* error.c - signalling scheme errors
 *
 ****************************************************************
 * Copyright (C) 1995,1996,1997,1998 Free Software Foundation, Inc.
 * 
 * This software comes with NO WARRANTY.
 * This software is publicly licensed under the terms of
 * the GNU General Public License, version 2, which is included
 * with the source code.
 *
 */

/************************************************************************
 *(h0 "Conventions for Errors")
 *
 * Errors in built-ins usually generate exceptions of type
 * `parameter-error'.   Exceptions are thrown:
 *
 *	(throw 'parameter-error msg-string procedure-name . data)
 *
 * Usually the CAR of `data' is the errant parameter or a substructure
 * of the errant parameter, but `data' may be `()'.
 *
 * Errors in `eval' generate exceptions of the type `eval-error':
 *
 *	(throw 'eval-error procedure-or-procedure-name
 *
 * Unhandled signals generate an exception of type `signal':
 *
 *	(throw 'signal signal-name)
 *
 * A stack depth exceeded condition generates an exception of 
 * type `stack-depth':
 *
 *	(throw 'stack-depth)
 */

/*(c fatal)
 * (fatal . args)
 * 
 * Display on the current error port an error message containing 
 * the arguments and exit the process with status 1.
 */

/*(c error)
 * (error . args)
 * 
 * Signal a generic error (exception type `error'), passing `args' to 
 * the error handler. (Does not return.)
 */


/****************************************************************
 *h1 "Error Handling Internals")
 *
 * Errors in built-ins are converted to exceptions by 
 * `scm_err_escape'.  `scm_wta' is a macro that has a 
 * simpler calling convention, but that simply invokes
 * `scm_err_escape'.
 *
 *	SCM_ASSERT (scm_is_symbol (key),
 *		    key, scm_arg1, s_this_procedure);
 *	// following code not reached if key is not a symbol
 *
 * Exceptions can also be generated by calling `scm_throw' or
 * `scm_handle' directly. (See "throw.c".)
 *
 * Exceptions may be `delayed' which means they are not
 * actually thrown (do not cause a non-local exit) until
 * the flag `scm_mask_ints' makes a transition to 0.  This
 * can be used to raise an exception during a Scheme critical
 * section (between SCM_DEFER_INTS and SCM_ALLOW_INTS) without
 * causing a (probitted) non-local exit from the critical
 * section.  For example:
 *
 *	SCM_DEFER_INTS;
 *	buffer = malloc (100);
 *	...so stuff..
 *	if (error_noticed)
 *	  {
 *	     scm_err_escape (1, scm_parameter_error, s_err_msg, ...);
 *	     // scm_err_escape returns here
 *	     free (buffer);
 *	     ... other cleanups ...
 *	  }
 *	else
 *	  ... no error noticed ...
 *
 *	SCM_ALLOW_INTS;	    // If an error was noticed, this doesn't return.
 *
 * The macro SCM_ASSERT in "error.h" is commonly used to 
 * detect errors and raise exceptions.
 */


#include <unistd.h>
#include <setjmp.h>
#include <sys/types.h>
#include "hackerlab/vu/vu.h"
#include "systas/libsystas/error.h"
#include "systas/libsystas/pairs.h"
#include "systas/libsystas/throw.h"
#include "systas/libsystas/strings.h"
#include "systas/libsystas/symbols.h"
#include "systas/libsystas/gc.h"

#ifdef __STDC__
#include <stdarg.h>
#define var_start(x, y) va_start(x, y)
#else
#include <varargs.h>
#define var_start(x, y) va_start(x)
#endif




/* Standard exception types.
 */
SCM_EXTERN_SYMBOL (scm_parameter_error, "parameter-error");
SCM_EXTERN_SYMBOL (scm_eval_error, "eval-error");
SCM_EXTERN_SYMBOL (scm_unknown_procedure, "unknown-procedure");
SCM_EXTERN_SYMBOL (scm_stack_depth, "stack-depth");

#undef SCM_STANDARD_ERROR_MESSAGE
#define SCM_STANDARD_ERROR_MESSAGE(c_name, string) SCM_EXTERN_STRING(c_name,string)
SCM_STANDARD_ERROR_MESSAGES



/* scm_err_escape
 * 
 * Signal an error.
 * 
 * If `delay_it' is not 0, exit non-locally.  Otherwise, schedule
 * a non-local exit for the next time `scm_mask_ints' makes a 
 * transition to 0.
 *
 * `msg' should be a string.  There is a list of standard error
 * messages in "error.h".
 *
 * `condition' should be a symbol -- the type of error that has
 * occured.  Usually, it should be one of:
 *
 *	scm_parameter_error	`system-error'
 *	scm_eval_error		`eval-error'
 *
 * The exception is thrown as:
 *
 *	(throw condition msg . args)
 */
void
scm_err_escape (int delay_it, SCM condition, SCM msg, SCM elt, ...)
{
  SCM_INTS_UNKNOWN;
  va_list foo;
  SCM args;
  SCM *pos;

  var_start (foo, elt);
  args = SCM_EOL;
  pos = &args;

  while (elt != SCM_UNDEFINED)
    {
      *pos = scm_cons (elt, SCM_EOL);
      pos = &SCM_CDR (*pos);
      elt = va_arg (foo, SCM);
    }

  if (delay_it)
    scm_defer_exception (condition, scm_cons (msg, args));
  else
    scm_ithrow (condition, scm_cons (msg, args), 1);
}


/* Signal an error of type system-error with arguments:
 *
 * 	message subr argument-value
 *
 * argument-value may be SCM_UNDEFINED.
 *
 * subr may be 0 in which case the symbol `unknown-procedure' is 
 * substituted.
 */
void
scm_wta (SCM arg, SCM msg, SCM subr)
{
  scm_err_escape (0,
		  scm_parameter_error,
		  msg,
		  (subr ? subr : scm_unknown_procedure),
		  arg,
		  SCM_UNDEFINED);
  
}


/* scm_delayed_error
 *
 * schedule an exception which will be delivered 
 * when scm_mask_ints makes a transition to 0.  
 * (See "Asyncs Internals" in "async.c".)
 */
void
scm_delayed_error (SCM arg, SCM msg, SCM subr)
{
  scm_err_escape (1, scm_parameter_error,
		  msg,
		  (subr ? subr : scm_unknown_procedure),
		  arg,
		  SCM_UNDEFINED);
}


/* scm_panic
 * 
 * Print a message on descriptor 2 and exit the process
 * immediately.
 */
void
scm_panic (char * desc)
{
  int errn;
  vu_write (&errn, 2, "SCM panic ", 10);
  vu_write (&errn, 2, desc, strlen (desc));
  vu_write (&errn, 2, "\n", 1);
  exit (1);
}




void
scm_init_error (void)
{
  SCM_INTS_DISABLED;

#include "systas/libsystas/error.x"
}

