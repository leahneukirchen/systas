;;; sched.scm:  A scheduler for lightweight processes, idle tasks,
;;;		select handlers, etc.
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Copyright (C) 1998, 2002 Tom Lord
;;; This software comes with NO WARRANTY.
;;; The Liberty Software License, version 2:
;;; 	1. This license is valid for all people.
;;;	2. You may use this software without restriction.
;;;



(define-module (ice-9 sched)
  :use-module (standard define-record-type))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Hook into the stack scheduler
;;

(begin
  (define-public (idle-task . ign)
    (catch #t
	   (lambda ()
	     (polling-step)
	     (select-step)
	     (waitpid-step)
	     (timer-step)
	     (if (not (q-empty? flyweight-q))
		 (catch #t
			(lambda () ((deq! flyweight-q)))
			(lambda args (warn "exception during flyweight task" args)))))
	   (lambda args
	     (warn "exception during idle task" args))))
  (set! scm-idle-task idle-task))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Flyweight tasks -- don't even get their own stack.
;;

(define-public flyweight-q (make-q))
(define-public (add-flyweight-event t) (enq! flyweight-q t))
(define-public (remove-flyweight-event t) (q-remove! flyweight-q t))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Polling-based events
;; 

(define polling-events ())

(define (polling-step)
  (without-interrupts
   (lambda ()
     (let ((p polling-events))
       (set! polling-events ())
       (let loop ((pos p))
	 (cond
	  ((null? pos)		())
	  (((caar pos))		(enq! flyweight-q (cadar pos))
				(loop (cdr pos)))
	  (else			(loop (cdr pos)))))))))

(define-public (add-polling-event poll-thunk event-thunk)
  (without-interrupts
   (lambda () 
     (set! polling-events `((,poll-thunk ,event-thunk) ,@ polling-events)))))

(define-public (remove-polling-event poll-thunk event-thunk)
  (without-interrupts
   (lambda ()
     (and=> (assq poll-thunk polling-events)
	    (lambda (p) (set! polling-events (delq! p polling-events)))))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Clock-driven events
;;
;; Using %gettimeofday times, i.e. (sec msec).
;; 

(define timer-events '())

(define-public (timer-point<=? a b)
  (or (< (car a) (car b))
      (and (= (car a) (car b))
	   (<= (cadr a) (cadr b)))))

(define-public (timer-point<? a b)
  (or (< (car a) (car b))
      (and (= (car a) (car b))
	   (< (cadr a) (cadr b)))))

(define-public (timer-point=? a b)
  (and (= (car a) (car b))
       (= (cadr a) (cadr b))))

(define-public (timer-subtract a b)
  (let* ((a-sec		(car a))
	 (a-msec	(cadr a))
	 (b-sec		(car b))
	 (b-msec	(cadr b)))

    (cond
     ((timer-point<? a b)		`(0 0))
     ((> b-msec a-msec)			`(,(- a-sec 1 b-sec)	,(- (+ 1000 a-msec) b-msec)))
     (#t				`(,(- a-sec b-sec)	,(- a-msec b-msec))))))

(define-public (add-timer-event sec msec proc)
  (without-interrupts
   (lambda ()
     (let ((this-event 	`((,sec ,msec) ,pos)))
       (if (null? timer-events)
	   (set! timer-events `(,this-event))

	   (let loop ((pos timer-events))
	     (cond
	      ((timer-point<? (caar pos) (car this-event))		(if (null? (cdr pos))
									    (set-cdr! pos this-event)
									    (loop (cdr pos))))
	      (#t							(let ((follow-event (car pos)))

									  (set-car! pos this-event)
									  (set-cdr! pos (cons follow-event (cdr pos))))))))))))

(define-public (remove-timer-event sec msec proc)
  (without-interrupts
   (lambda ()
     (let ((this-event 	`((,sec ,msec) ,pos)))
       (set! timer-events (delete this-event timer-events))))))

(define-public (timer-value) (car (%% %gettimeofday)))
(define last-timer-value (timer-value))

(define (timer-step)
  (without-interrupts
   (lambda ()
     (set! last-timer-value (timer-value))
     (let loop ((pos timer-events))
       (cond
	((null? pos)					(set! timer-events ()))
	((timer-point<? last-timer-value (caar pos)) 	(set! timer-value pos))
	(else						(enq! flyweight-q (cadar pos))
							(loop (cdr pos))))))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Events generated by select(2)
;;

(define scm-fd-read-events '())
(define scm-fd-write-events '())
(define scm-fd-exception-events '())

(define scm-default-select-timeout `(5 0))

(define-public (select-step)
  (without-interrupts
   (lambda ()
     (if (or scm-fd-read-events scm-fd-write-events scm-fd-exception-events)
	 (let ((select-result (apply %select
				     (map car scm-fd-read-events)
				     (map car scm-fd-write-events)
				     (map car scm-fd-exception-events)
				     ;; If there is anything else to do, don't block
				     ;; in select at all.
				     ;;
				     ;; If there is nothing else to do, block for the 
				     ;; least of the next timer event and the default 
				     ;; select time (the default polling interval).
				     ;;
				     ;; If the timeout is determined by a timer event,
				     ;; be careful because the deadline for that event
				     ;; might already be past -- in which case don't
				     ;; block in select.
				     ;;
				     (cond
				      ((not (q-empty? scm-stack-q))	`(0))
				      ((not (q-empty? flyweight-q))	`(0))
				      ((null? timer-events)		scm-default-select-timeout)
				      (else 				(let* ((next-timer-event	(caar timer-events))
									       (now			(timer-value)))
									  (timer-subtract next-timer-event now)))))))

	   (if (errno? select-result)
	       (warn "select returned an error in scheduler" select-result)
	       (apply-to-args select-result
		 (lambda (reads writes exceptions)
		   (set! scm-fd-read-events (issue-select-callbacks reads scm-fd-read-events))
		   (set! scm-fd-write-events (issue-select-callbacks writes scm-fd-write-events))
		   (set! scm-fd-exception-events (issue-select-callbacks exceptions scm-fd-exception-events))))))))))

(define (issue-select-callbacks matched alist)

  (let loop ((alist	alist)
	     (answer	'()))

    (cond
     ((null? alist)				answer)

     ((memq? (caar alist) matched)		(enq! flyweight-q (cadar alist))
						(loop (cdr alist) answer))

     (#t					(loop (cdr alist) (cons (car alist) answer))))))


(define-public (add-read-select-event fd callback)
  (without-interrupts
   (lambda ()
     (set! scm-fd-read-events `((,fd ,callback) ,@ scm-fd-read-events)))))

(define-public (add-write-select-event fd callback)
  (without-interrupts
   (lambda ()
     (set! scm-fd-write-events `((,fd ,callback) ,@ scm-fd-write-events)))))

(define-public (add-exception-select-event fd callback)
  (without-interrupts
   (lambda ()
     (set! scm-fd-exception-events `((,fd ,callback) ,@ scm-fd-exception-events)))))

(define-public (remove-read-select-event fd callback)
  (without-interrupts
   (lambda ()
     (let ((event 	`(,fd ,callback)))
       (set! scm-fd-read-events (delete! event scm-fd-read-events))))))

(define-public (remove-write-select-event fd callback)
  (without-interrupts
   (lambda ()
     (let ((event 	`(,fd ,callback)))
       (set! scm-fd-write-events (delete! event scm-fd-write-events))))))

(define-public (remove-exception-select-event fd callback)
  (without-interrupts
   (lambda ()
     (let ((event 	`(,fd ,callback)))
       (set! scm-fd-exception-events (delete! event scm-fd-exception-events))))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Events generated by waitpid
;;

(define (waitpid-step) #f)

; 
; (define scm-pid-events '())
; 
; (define-public (add-pid-event pid proc)
;   (remove-pid-event pid)
;   (set! scm-pid-events (cons (list pid proc) scm-pid-events)))
; 
; (define-public (remove-pid-event pid)
;   (while (assq pid scm-pid-events)
; 	 (set! scm-pid-events (assq-remove! scm-pid-events pid))))
; 
; (define (get-pid-event pid)
;   (let ((ans (assq pid scm-pid-events)))
;     (remove-pid-event pid)
;     (and ans (cadr ans))))
; 
; (define (waitpid-step)
;   (let loop ((wp (%waitpid -1 (logior WNOHANG WUNTRACED))))
;     (if (not (errno? wp))
; 	(apply-to-args wp
; 	  (lambda (pid status sig)
; 	    (let ((cb (get-pid-event pid)))
; 	      (and cb
; 		   (add-flyweight-event
; 		    (lambda () (cb status sig))))))))))
; 
; (set! chld-thunk noop)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Heavyweight procs
;;

(begin
  (define-record-type scheme-proc
    (make-scheme-proc name state pending-signals stack)
    scheme-proc?
    (name		scheme-proc:name		set-scheme-proc:name!)
    (state		scheme-proc:state		set-scheme-proc:state!)
    (pending-signals	scheme-proc:pending-signals	set-scheme-proc:pending-signals!)
    (static		scheme-proc:stack		set-scheme-proc:stack!))

  (define-public scheme-proc:name scheme-proc:name)
  (define-public scheme-proc:state scheme-proc:state))


(define the-proc #f)
(define runnable-procs (make-q))
(define other-procs (make-q))

(define-public (current-proc) the-proc)
(define-public (current-runnable-procs) (q-members runnable-procs))
(define-public (current-other-procs) (q-members other-procs))

(define-public (start-proc name thunk)
  (let ((p (pk 'proc (make-scheme-proc name 'new () #f))))
    (pk 'set-stack (set-scheme-proc:stack! p (pk 'booter (proc-booter p thunk))))
    (pk 'runnable (make-proc-runnable (pk 'make-runnable p)))))

(define (proc-booter p thunk)
  (lambda (k)
    (dynamic-wind
     
     (lambda ()
       (set! the-proc p)
       (set! proc-switch
	     (lambda opt
	       (call-with-current-continuation
		(lambda (k)
		  (set-scheme-proc:stack! p k)
		  (if (eq? 'runnable (scheme-proc:state p))
		      (enq! flyweight-q goto-runnable-proc))
		  (scm-switch-stack #f))))))

     (lambda ()
       (catch #t
	      (lambda ()
		(thunk))
	      (lambda err (warn "proc exitted abnormally" err)))
       
       (without-interrupts
	(lambda ()
	  (q-remove! runnable-procs p)
	  (q-remove! other-procs p)))
       (scm-switch-stack #f))
     
     (lambda ()
       (set! the-proc #f)
       (set! proc-switch #f)))))


;; proc-switch reliably suspends the current process, even if it 
;; is going to immediately be rescheduled.
;;
(define-public proc-switch #f)


;; proc-idle polls for pending flyweight tasks and suspends
;; the current process only if some are found.
;;
(define-public (proc-idle . ign)
  (polling-step)
  (select-step)
  (timer-step)
  (if (not (q-empty? flyweight-q))
      (proc-switch)))

(define (make-proc-runnable p)
  (without-interrupts
   (lambda ()
     (if (not (eq? 'runnable (scheme-proc:state p)))
	 (begin
	   (set-scheme-proc:state! p 'runnable)
	   (pk 'changed-state)
	   (q-remove! other-procs p)
	   (pk 'removed-from-others)
	   (enq! runnable-procs p)
	   (pk 'enqueued-runnable)
	   (pk 'fuck (enq! flyweight-q goto-runnable-proc)))))))

(define (make-proc-blocked p)
  (without-interrupts
   (lambda ()
     (if (not (eq? 'blocked (scheme-proc:state p)))
	 (begin
	   (set-scheme-proc:state! p 'blocked)
	   (q-remove! runnable-procs p)
	   (enq! other-procs p))))))

(define (goto-runnable-proc)
  (let ((p #f))
    (without-interrupts
     (lambda () 
       (if (not (q-empty? runnable-procs))
	   (set! p (q-rotate runnable-procs)))))
    (if p
	(scm-switch-stack (scheme-proc:stack p)))))



;;; tag: Tom Lord Mon Apr 15 14:17:13 2002 (ice-9/sched.scm)
;;;
