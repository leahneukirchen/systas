;;; http-errors.scm:
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Portions Copyright (c) 2001, 2002 by Tom Lord
;;; 
;;; See the file "=copyright-conditions" for further information about
;;; the copyright and warranty status of this work.
;;; 
;;; Portions Copyright (c) 1994 by Brian D. Carlstrom and Olin Shivers.
;;; 
;;; This is a nearly complete rewrite of some of the sunet network
;;; library, based on reading Olin and Brian's comments and code, and
;;; borrowing some interfaces.  Several comments in this file are
;;; quotes from that code.  All of the code here is rewritten, but
;;; while most was written from scratch, a small amount was written by
;;; making "correctness preserving (or increasing)" transformations on
;;; the old code
;;;
;;; 
;;; See the file "=scsh-copyright" for the permissions for Olin's
;;; code.
;;;



(define-module (http http-errors)
  :use-module (http http-request)
  :use-module (http http-replies))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Signalling HTTP-specific Errors
;;;
;;; By convention, all HTTP errors throw an exception with:
;;; 
;;; 	(throw 'http-error code request message . data)
;;;  
;;; The procedure `http-error' does that conveniently.
;;; 
;;; The procedure `http-catch' receives such errors.
;;; 
;;; The `request' may be #f is no request has been formed yet.
;;; 
;;; The `code' should be a symbol from the alist http-reply-codes.
;;; 
;;; The `message' is a short string that further describes the
;;; error condition, or #f.
;;; 


;; http-error code :optional request message . data => does not return
;; 
;; Almost equivalent to:
;; 
;; 	(apply throw 'http-error code request data)
;; 
;; However, `http-error' checks its arguments and makes sure
;; that the code, request, and message are valid data.
;; 
;; If they are not, the error is converted to an `internal-scheme-error'
;; (a synonym for `internal-error', HTTP reply code 500).
;; 
;; When throwing an error of type `moved-temp' or `moved-perm', 
;; `message' should be the new URI for the moved resource.
;; 
(define-public (http-error code :optional request message . data)
  (let* ((valid-code?		(assq-ref http-reply-codes code))
	 (valid-reqeuest?	(or (eq? #f request)
				    (http-request? request)))
	 (valid-message?	(or (eq? #f message)
				    (read-only-string? message))))

    (if (and valid-code? valid-reqeuest? valid-message?)
	(apply throw 'http-error code request message data)

	(apply throw
	       'http-error
	       'internal-scheme-error
	       (if valid-reqeuest? request #f)
	       (if valid-message? message #f)
	       data))))


;; http-catch type body handler
;; 
;; Similar to `catch', but with special treatment of the 
;; exception type and some transmogrifying of the exception
;; data given to the handler.
;; 
;; If `type' is a symbol, it should be an http error code
;; from the alist `http-reply-codes'.  In this case, 
;; if an error of type `http-error' is signaled, with a matching
;; code, then `handler' is called.
;; 
;; If `type' is #t, then any all (well-formed) errors of type `http-error'
;; are passed to `handler'.
;; 
;; If `type' is #f, then all exceptions are passed to handler.  However,
;; if the real exception is not an `http-error' or is an ill-formed 
;; `http-error', it is first converted to an `http-error' with the
;; code `internal-scheme-error' (a synonym for `internal-error').
;; 
;; The `handler' is invoked:
;; 
;; 	(handler code request message . data)
;; 
;; where `code' is an http error code, `request' an `http-request' or
;; #f, `message' is #f or a short string describing the error in
;; detail, and `data' is arbitrary data (see `http-error').
;; 
;; For an `internal-scheme-error' generated by `http-catch',
;; the arguments to `handler' are:
;; 
;;   	(handler 'internal-scheme-error
;;		 #f
;; 		 "unrecognized exception caught" 
;; 		 original-exception
;;		 . data)
;; 
;; This procedure checks its `type' argument and signals an error
;; if it is not #f, #t, or a valid reply code.
;; 
(define-public (http-catch type body handler)

  (if (and (not (boolean? type))
	   (not (kw-arg-ref http-reply-codes)))
      (error "Wrong type argument to http-catch" type))
  
  (let ((catch-type		(case type
				  ((#f)		#t)
				  ((#t)		'http-error)
				  (else		'http-error))))

    (catch catch-type
      body

      (lambda (exception . data)

	(check-http-error exception data

			  ;; Yes, it's a well formed http error
			  ;; 
			  (lambda (code request message . wf-data)
			    (cond
			     ((or (boolean? type)
				  (eq? type code))		(apply handler code request message wf-data))

			     (#t				(apply throw exception data))))

			  ;; No, it's not a well formed http error.
			  ;; 
			  (lambda ()
			    (cond
			     ((boolean? type)			(apply handler 'internal-scheme-error #f "ill-formed http-error exception" exception data))

			     (#t				(apply throw exception data)))))))))


(define (check-http-error exception data well-formed not-well-formed)
  (cond
   ((and (eq? exception 'http-error)
	 (pair? data)
	 (assq-ref http-reply-codes (car data))
	 (pair? (cdr data))
	 (or (eq? #f (cadr data))
	     (http-request? (cadr data)))
	 (pair? (cddr data))
	 (or (eq? #f (caddr data))
	     (read-only-string? (caddr data))))			(apply well-formed data))

   (#t								(not-well-formed))))
 

;;; tag: Tom Lord Sat Apr 13 11:00:16 2002 (http/http-errors.scm)
;;;

